\documentclass[12pt, fleqn]{article}

\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\title{Лемматизация итальянских слов}
\author{Азат Давлетшин}

\begin{document}
\maketitle
\section{Формулировка задачи}
Имеется два множества \textbf{X} и \textbf{Y}. \textbf{X} - множество слов итальянского языка. \textbf{Y} - множество пар (слово в начальной форме + часть речи). Имеются отображения $f: \textbf{X} \rightarrow \textbf{Y}$ и $f^{*}$ - сужение $f$ на некоторое подмножество \textbf{X}. $f$ - считается неизвестным, $f^{*}$ - задано. Задача: экстраполировать $f^{*}$ на все множество \textbf{X} как можно точнее. Критерий качества: доля правильных ответов на тестовой выборке.
\section{Сведение к задаче классификации}
Нужно выделить классы так, чтобы по классу можно было однозначно получить начальную форму и часть речи. Кроме того, желательно получить как можно меньше классов. В моем решении классом является следующий объект: (toDelete, toAdd, POS)
\begin{description}
\item[toDelete] - целое число. Количество символов, которые нужно удалить с конца слова.
\item[toAdd] - строка. Что необходимо добавить в конец слова.
\item[POS] - символ. Часть речи
\end{description}
На исходных данных получилось примерно 250 классов.
\section{Выделение признаков}
Очевидно, что наиболее значимыми являются окончания. Для упрощения кодирования в качестве признаков были выбраны всевозможные суффиксы. Для того, чтобы получить матрицу признаков с помощью CountVectorizer, был сделан следующий хак: всевозможные суффиксы записывались в одно предложение. Например слово <<Азат>> $\rightarrow$ <<Азат зат ат т>>. Далее запускался CountVectorizer в режиме <<word>>, с параметром ngram\_range = (1,1) - очевидно почему.
\section{Классификатор}
Поскольку фичи сильно разрежены, то в качестве классификатора был выбран LinearSVC со стандартными параметрами.
\section{Результат}
Время работы алгоритма составило примерно 15 минут. Результат на kaggle.com: $\textbf{87,626\%}$ качества.
\end{document}